#include "q1buffer.h"
#include <cstring>
#include <cerrno>
#include <iostream>
#include <string>
#include <sstream>
using namespace std;
#include <cstdlib>

bool convert( int &val, const char *buffer ) {		// convert C string to integer
    stringstream ss( buffer );			            // connect stream and buffer
    ss >> dec >> val;					            // convert integer from buffer
    return ! ss.fail() &&				            // conversion successful ?

	// characters after conversion all blank ?
	string( buffer ).find_first_not_of( " ", ss.tellg() ) == string::npos;
} // convert


void usage( char *argv[] ) {
    cerr << "Usage: " << argv[0]
	     << " [ Cons (> 0) " 
         << "[ Prods (> 0) [ Produce (> 0) [ BufferSize (> 0) [ Delays (> 0) ] ] ] ] ]" << endl;
    exit( EXIT_FAILURE );				            // TERMINATE
} // usage


void uMain::main(void) {

    int cons = 5;                               // Default value of number of consumers
    int prods = 3;                              // Default value of number of producers 
    int produce = 10;                           // Default value of items generated by producers
    int bufferSize = 10;                        // Default value of size of bounder buffer
    int delay = cons + prods;                   // Default value of delay
    int sentinel = -1;                          // Default value of sentinel
    
    switch ( argc ) {
        case 6:
            if ( ! convert ( delay, argv[5] ) || delay <= 0 ) {
                usage ( argv );
            }
        case 5:
            if ( ! convert ( bufferSize, argv[4] ) || bufferSize <= 0 ) {
                usage ( argv );
            }
        case 4:
            if ( ! convert ( produce, argv[3] ) || produce <= 0 ) {
                usage ( argv );
            }
            // FALL THROUGH
        case 3:
            if ( ! convert ( prods, argv[2] ) || prods <= 0 ) {
                usage ( argv );
            }
            // FALL THROUGH
        case 2:
            if ( ! convert ( cons, argv[1] ) || cons <= 0 ) {
                usage ( argv );
            }
            // FALL THROUGH
        case 1:
            break;
        default:						                // wrong number of options
            usage( argv );
    } // switch

#ifdef __U_MULTI__
    uProcessor p[3] __attribute__(( unused ));          // create 3 kernel thread for a total of 4
#endif // __U_MULTI__

    int sum = 0;
    BoundedBuffer<int> boundedBuffer(bufferSize);
    Producer *producer[prods];
    Consumer *consumer[cons];

    for (int i = 0; i < prods; i++){ // Start producer threads
        producer[i] = new Producer(boundedBuffer, produce, delay);
    }    

    for (int i = 0; i < cons; i++){ // Start consumer threads
        consumer[i] = new Consumer(boundedBuffer, delay, sentinel, sum);
    }

    for (int i = 0; i < prods; i++){ // wait for producer threads to terminate
        delete producer[i];
    }

    for (int i = 0; i < cons; i++){ // insert stopping value for consumers 
        boundedBuffer.insert(sentinel);
    }
    
    for (int i = 0; i < cons; i++){ // wait for consumer threads to terminate
        delete consumer[i];
    }

    cout << "total: " << sum << endl; // output result
}
